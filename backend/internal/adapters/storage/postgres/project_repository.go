package postgres

import (
	"errors"


	"github.com/google/uuid"
	"github.com/phuc/cmms-backend/internal/domain"
	"gorm.io/gorm"
)

// Struct definition remains same
type projectRepository struct {
	db *gorm.DB
}

func NewProjectRepository(db *gorm.DB) domain.ProjectRepository {
	return &projectRepository{db: db}
}

func (r *projectRepository) GetAllProjects() ([]domain.Project, error) {
	var projects []domain.Project
	if err := r.db.Find(&projects).Error; err != nil {
		return nil, err
	}
	return projects, nil
}

func (r *projectRepository) GetProjectCount() (int64, error) {
    var count int64
    if err := r.db.Model(&domain.Project{}).Count(&count).Error; err != nil {
        return 0, err
    }
    return count, nil
}



func (r *projectRepository) GetProjectByID(id uuid.UUID) (*domain.Project, error) {
    var project domain.Project
    if err := r.db.Where("project_id = ?", id).First(&project).Error; err != nil {
        return nil, err
    }
    return &project, nil
}

func (r *projectRepository) GetAllClassifications() ([]domain.ProjectClassification, error) {
	var classifications []domain.ProjectClassification
	if err := r.db.Find(&classifications).Error; err != nil {
		return nil, err
	}
	return classifications, nil
}

func (r *projectRepository) GetClassificationByID(id uuid.UUID) (*domain.ProjectClassification, error) {
	var c domain.ProjectClassification
	if err := r.db.Where("id = ?", id).First(&c).Error; err != nil {
		return nil, err
	}
	return &c, nil
}

func (r *projectRepository) GetAllMainCategories() ([]domain.MainCategory, error) {
	var categories []domain.MainCategory
	if err := r.db.Find(&categories).Error; err != nil {
		return nil, err
	}
	return categories, nil
}

func (r *projectRepository) GetChildCategoriesByMainID(mainID uuid.UUID) ([]domain.ChildCategory, error) {
	var categories []domain.ChildCategory
	if err := r.db.Where("id_main_categories = ?", mainID).Find(&categories).Error; err != nil {
		return nil, err
	}
	return categories, nil
}

func (r *projectRepository) GetChildCategoriesByStationID(stationID uuid.UUID) ([]domain.ChildCategory, error) {
	var categories []domain.ChildCategory
	if err := r.db.Where("id_station = ?", stationID).Find(&categories).Error; err != nil {
		return nil, err
	}
	return categories, nil
}

// func (r *projectRepository) GetCharacteristicsByMainID(mainID uuid.UUID) ([]domain.ProjectCharacteristic, error) {
// 	return nil, nil // API deprecated due to schema change
// }

func (r *projectRepository) GetProjectCharacteristic(projectID uuid.UUID) (*domain.ProjectCharacteristic, error) {
	var char domain.ProjectCharacteristic
	if err := r.db.Where("id_project = ?", projectID).First(&char).Error; err != nil {
		return nil, err
	}
	return &char, nil
}

func (r *projectRepository) GetProjectsByUserID(userID uuid.UUID) ([]domain.Project, error) {
	var projects []domain.Project
	// Join with assign table to find projects assigned to this user
	if err := r.db.Model(&domain.Project{}).
		Joins("JOIN assign ON assign.id_project = projects.project_id").
		Where("assign.id_user = ?", userID).
		Distinct("projects.*").
		Find(&projects).Error; err != nil {
		return nil, err
	}
	return projects, nil
}

// Creation support methods
func (r *projectRepository) CreateProject(p *domain.Project) error {
	return r.db.Create(p).Error
}

func (r *projectRepository) UpdateProject(p *domain.Project) error {
    return r.db.Save(p).Error
}

func (r *projectRepository) CreateMainCategory(c *domain.MainCategory) error {
	return r.db.Create(c).Error
}

func (r *projectRepository) CreateChildCategory(c *domain.ChildCategory) error {
	return r.db.Create(c).Error
}

func (r *projectRepository) CreateClassification(c *domain.ProjectClassification) error {
	return r.db.Create(c).Error
}

func (r *projectRepository) CreateCharacteristic(c *domain.ProjectCharacteristic) error {
	return r.db.Create(c).Error
}

func (r *projectRepository) UpdateProjectCharacteristic(projectID uuid.UUID, c *domain.ProjectCharacteristic) error {
	// Check if exists
	var existing domain.ProjectCharacteristic
	err := r.db.Where("id_project = ?", projectID).First(&existing).Error
	
	if errors.Is(err, gorm.ErrRecordNotFound) {
		// Create new
		c.ProjectID = projectID // Ensure link
		// ID generated by GORM/DB
		return r.db.Create(c).Error
	} else if err != nil {
		return err
	}

	// Update existing
	// We want to update all fields provided in 'c'. 
    // GORM 'Updates' only updates non-zero fields struct. 
    // If 'c' has 0 for some fields and we want to set them to 0, we might need map or Select("*").
    // Based on user screenshot, they want to set quantities (maybe to 0).
    // So we should be careful. 
    // Assuming 'c' comes from JSON binding which might have partial data?
    // Actually, typical use case is "Save Changes" form which sends full data.
    // Let's use Save() on the existing object with new values, or Updates() with care.
    
    // Simplest robust update for full form save:
    c.ID = existing.ID // Preserve ID
    c.ProjectID = projectID
    return r.db.Save(c).Error
}

func (r *projectRepository) DeleteProject(id uuid.UUID) error {
	return r.db.Transaction(func(tx *gorm.DB) error {
		// 1. Get all Assigns for this project
		var assigns []domain.Assign
		if err := tx.Where("id_project = ?", id).Find(&assigns).Error; err != nil {
			return err
		}

		// 2. Hard-delete TaskDetails and Assigns
		for _, a := range assigns {
			// Hard-delete TaskDetails (Unscoped bypasses soft delete)
			if tx.Migrator().HasTable(&domain.TaskDetail{}) {
				if err := tx.Unscoped().Where("assign_id = ?", a.ID).Delete(&domain.TaskDetail{}).Error; err != nil {
					return err
				}
			}
			// Hard-delete the Assign record itself
			if err := tx.Unscoped().Delete(&domain.Assign{}, "id = ?", a.ID).Error; err != nil {
				return err
			}
		}

		// 3. Get all Stations for this project, then delete their child configs
		var stations []domain.Station
		if err := tx.Where("id_project = ?", id).Find(&stations).Error; err != nil {
			return err
		}
		for _, s := range stations {
			// StationChildConfig has no DeletedAt → regular delete is already permanent
			if err := tx.Where("station_id = ?", s.ID).Delete(&domain.StationChildConfig{}).Error; err != nil {
				return err
			}
		}
		// Hard-delete all Stations for this project
		if len(stations) > 0 {
			if err := tx.Unscoped().Where("id_project = ?", id).Delete(&domain.Station{}).Error; err != nil {
				return err
			}
		}

		// 4. Hard-delete Project Characteristics
		if tx.Migrator().HasTable(&domain.ProjectCharacteristic{}) {
			if err := tx.Unscoped().Where("id_project = ?", id).Delete(&domain.ProjectCharacteristic{}).Error; err != nil {
				return err
			}
		}

		// 5. Finally, hard-delete the Project itself
		return tx.Unscoped().Delete(&domain.Project{}, "project_id = ?", id).Error
	})
}


func (r *projectRepository) UpdateMainCategory(id uuid.UUID, name string) error {
	return r.db.Model(&domain.MainCategory{}).Where("id = ?", id).Update("name", name).Error
}

func (r *projectRepository) DeleteMainCategory(id uuid.UUID) error {
	return r.db.Transaction(func(tx *gorm.DB) error {
		// 1. Get Child Categories
		var children []domain.ChildCategory
		if err := tx.Where("id_main_categories = ?", id).Find(&children).Error; err != nil {
			return err
		}

		// 2. Delete dependent TaskDetails for each child
		for _, child := range children {
			if tx.Migrator().HasTable(&domain.TaskDetail{}) {
				if err := tx.Where("child_category_id = ?", child.ID).Delete(&domain.TaskDetail{}).Error; err != nil {
					return err
				}
			}
		}

		// 3. Delete Child Categories
		if err := tx.Where("id_main_categories = ?", id).Delete(&domain.ChildCategory{}).Error; err != nil {
			return err
		}

		// 4. Delete Main Category
		return tx.Delete(&domain.MainCategory{}, "id = ?", id).Error
	})
}

func (r *projectRepository) UpdateChildCategory(id uuid.UUID, updates map[string]interface{}) error {
	// 1. Get current Child Category to find its MainCategoryID
	var currentChild domain.ChildCategory
	if err := r.db.First(&currentChild, id).Error; err != nil {
		return err
	}

	// 2. If name is changing, check for duplicate
    if name, ok := updates["name"].(string); ok && name != "" && name != currentChild.Name {
        var count int64
        if err := r.db.Model(&domain.ChildCategory{}).
            Where("id_main_categories = ? AND name = ? AND id != ?", currentChild.MainCategoryID, name, id).
            Count(&count).Error; err != nil {
            return err
        }
    
        if count > 0 {
            return errors.New("Sub-category name already exists in this Main Category")
        }
    }

	// 3. Update
	return r.db.Model(&domain.ChildCategory{}).Where("id = ?", id).Updates(updates).Error
}

func (r *projectRepository) DeleteChildCategory(id uuid.UUID) error {
	return r.db.Transaction(func(tx *gorm.DB) error {
		// 1. Delete dependent TaskDetails
		if tx.Migrator().HasTable(&domain.TaskDetail{}) {
			if err := tx.Where("child_category_id = ?", id).Delete(&domain.TaskDetail{}).Error; err != nil {
				return err
			}
		}

		// 2. Delete Child Category
		return tx.Delete(&domain.ChildCategory{}, "id = ?", id).Error
	})
}

// CloneProject creates a deep copy of a project and all its configuration:
// Project record -> ProjectCharacteristic -> Stations -> StationChildConfigs
func (r *projectRepository) CloneProject(id uuid.UUID) (*domain.Project, error) {
	var cloned *domain.Project

	err := r.db.Transaction(func(tx *gorm.DB) error {
		// 1. Fetch the source project
		var src domain.Project
		if err := tx.Where("project_id = ?", id).First(&src).Error; err != nil {
			return err
		}

		// 2. Create the clone Project
		newProject := domain.Project{
			ID:          uuid.New(),
			ProjectName: src.ProjectName + " (Copy)",
			Owner:       src.Owner,
			Area:        src.Area,
			Location:    src.Location,
		}
		if err := tx.Create(&newProject).Error; err != nil {
			return err
		}
		cloned = &newProject

		// 3. Clone ProjectCharacteristic (if exists)
		var srcChar domain.ProjectCharacteristic
		if err := tx.Where("id_project = ?", id).First(&srcChar).Error; err == nil {
			// Record found - clone it
			newChar := domain.ProjectCharacteristic{
				ID:                   uuid.New(),
				ProjectID:            newProject.ID,
				ChildCategoryData:    srcChar.ChildCategoryData,
				Inverter:             srcChar.Inverter,
				InverterSubAreaCount: srcChar.InverterSubAreaCount,
				InverterDetails:      srcChar.InverterDetails,
			}
			if err := tx.Create(&newChar).Error; err != nil {
				return err
			}
		}
		// If record not found, that's fine - skip silently

		// 4. Clone Stations and their StationChildConfigs
		var srcStations []domain.Station
		if err := tx.Where("id_project = ?", id).Find(&srcStations).Error; err != nil {
			return err
		}

		for _, srcStation := range srcStations {
			newStationID := uuid.New()
			newStation := domain.Station{
				ID:               newStationID,
				Name:             srcStation.Name,
				ProjectID:        newProject.ID,
				MainCategoryID:   srcStation.MainCategoryID,
				ChildCategoryIDs: srcStation.ChildCategoryIDs,
				// AssignID is intentionally NOT copied—new project starts unassigned
			}
			if err := tx.Create(&newStation).Error; err != nil {
				return err
			}

			// Clone StationChildConfigs for this station
			var srcConfigs []domain.StationChildConfig
			if err := tx.Where("station_id = ?", srcStation.ID).Find(&srcConfigs).Error; err != nil {
				return err
			}
			for _, srcCfg := range srcConfigs {
				newCfg := domain.StationChildConfig{
					ID:                      uuid.New(),
					StationID:               newStationID,
					ChildCategoryID:         srcCfg.ChildCategoryID,
					ProcessIDs:              srcCfg.ProcessIDs,
					ProjectClassificationID: srcCfg.ProjectClassificationID,
					GuideText:               srcCfg.GuideText,
					GuideImages:             srcCfg.GuideImages,
					ImageCount:              srcCfg.ImageCount,
				}
				if err := tx.Create(&newCfg).Error; err != nil {
					return err
				}
			}
		}

		return nil
	})

	if err != nil {
		return nil, err
	}
	return cloned, nil
}

